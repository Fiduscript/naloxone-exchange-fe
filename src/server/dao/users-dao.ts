import {IUserAddress } from '../../public/app/account/model/user-address';

import {DataMapper } from '@aws/dynamodb-data-mapper';
import {DynamoDB} from 'aws-sdk/clients/all';
import * as _ from 'lodash';
import {AWSProvider} from '../provider/aws-provider';
import {Logger} from '../util/logger';


import {
  attribute,
  autoGeneratedHashKey,
  hashKey,
  rangeKey,
  table,
} from '@aws/dynamodb-data-mapper-annotations';

const TABLE_NAME: string = 'user_address_test_two';
const ddb: DynamoDB = AWSProvider.getDynamoClient();
const mapper = new DataMapper({
  client: ddb,
});
const uuidV4 = require('uuid/v4');


const log = Logger.create(module);

// export interface UsersDao {
//   getAddressesForUser(id: string): [UserAddress];
  // createAddressForUser(id: string): [UserAddress];
  // deleteAddressForUser(userId: string);
  // getDependentsForUser(id: string): [Dependent];
  // createDependent(userId: string, dependent: Dependent);
  // updateDependent(userId: string, dependent: Dependent);
// }

@table(TABLE_NAME)
class AddressDdbEntity implements IUserAddress {

  @hashKey()
  userId: string;

  @rangeKey({defaultProvider: () => uuidV4()})
  addressId: string;

  @attribute()
  city: string;

  @attribute({defaultProvider: () => new Date()})
  createdOn: Date;

  @attribute()
  name: string;

  @attribute()
  state: string;

  @attribute()
  street: string;

  @attribute()
  street2: string;

  @attribute()
  zip: string;

  @attribute()
  phoneNumber: string;

  @attribute()
  specialInstructions: string;

  @attribute()
  weekendOkay: boolean;
}

export class UsersDao {

  public static create = _.once((): UsersDao => {
    return new UsersDao();
  });


  createAddress(address: IUserAddress): Promise<IUserAddress> {
    return mapper.put(Object.assign(new AddressDdbEntity, address));
  }


  async getAddressesForUser(userId: string): Promise<IUserAddress[]> {
    const total = [];
    const iterator = mapper.query(AddressDdbEntity, {'userId': userId});
    for await (const address of iterator ) {
      log.info('asdf');
      log.info(JSON.stringify(address));
      total.push(address);
    }
    return total;
  }


  // deleteAddressForUser(userId: string): void {
  //
  //   const params: DynamoDB.DeleteItemInput = {
  //     TableName: TABLE_NAME,
  //     Key: DynamoDB.Converter.marshall(userId)
  //   };
  //
  //   ddb.deleteItem(params, (err: AWSError, data: DynamoDB.PutItemOutput) => {
  //     if (err != null) {
  //       log.error(`Failed to unsubscribe customer \`${params}\`.` , err.message, err);
  //       res.status(500).json(new ErrorMessage('Unable to unsubscribe at this time. Please try again later.'));
  //     } else {
  //       res.status(201).json(new SuccessMessage('Successfully unsubscribed!'));
  //     }
  //   });
  // }
  // const params: DynamoDB.PutItemInput = {
  //   TableName: TABLE_NAME,
  //   Item: DynamoDB.Converter.marshall(req.body)
  // };
}

